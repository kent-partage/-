<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Partage Formation</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Lucide React Icons CDN - While Lucide React is meant for React, we'll embed the SVG directly in the React code within the script -->
    <!-- For standalone HTML, typically you'd use a different icon library or embed SVGs directly if not using React components. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX transformation in the browser (for demonstration purposes only, not for production) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        // Lucide React icons are imported as components in React.
        // For a single HTML file, we'll mimic their usage by defining them or
        // directly using inline SVGs.
        // For simplicity and direct compatibility, we'll define simple wrappers
        // for the required Lucide icons or assume they are available in a similar fashion.
        // In a real build, these would be compiled into the bundle.
        // Since the previous React code used Lucide React, we will make a small adjustment
        // to directly embed SVG for icons in the HTML version for simplicity, or define mock components.
        // For this example, we will define simple mock components for lucide-react icons that return SVGs.
        // In a real application, you would use a build step (like Create React App or Vite)
        // to handle these imports.

        // Mock Lucide React icons with inline SVGs for direct HTML embed
        const Icon = ({ children, size = 24, className = '', ...props }) => (
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width={size}
                height={size}
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className={className}
                {...props}
            >
                {children}
            </svg>
        );

        const ChevronDown = (props) => (
            <Icon {...props}>
                <path d="m6 9 6 6 6-6" />
            </Icon>
        );
        const Goal = (props) => (
            <Icon {...props}>
                <path d="M12 11v6" />
                <path d="M12 21a9 9 0 0 1-9-9V3h18v9a9 9 0 0 1-9 9z" />
                <path d="M7 11V3" />
                <path d="M17 11V3" />
                <path d="M3 3h18" />
            </Icon>
        );
        const Shield = (props) => (
            <Icon {...props}>
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
            </Icon>
        );
        const Swords = (props) => (
            <Icon {...props}>
                <path d="m14.5 17.5-7-7" />
                <path d="m17.5 14.5-7-7" />
                <path d="M14.5 14.5 9 19 5 15 9.5 10" />
                <path d="M4 4 9 9" />
                <path d="M15 5l4 4" />
                <path d="M19 9l-4.5 4.5" />
            </Icon>
        );
        const Users = (props) => (
            <Icon {...props}>
                <path d="M16 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" />
                <circle cx="12" cy="7" r="4" />
                <path d="M22 21v-2a4 4 0 0 0-3-3.87" />
                <path d="M6 17a4 4 0 0 1-3-3.87" />
                <path d="M16 3.13a4 4 0 0 1 0 7.75" />
            </Icon>
        );
        const User = (props) => (
            <Icon {...props}>
                <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
                <circle cx="12" cy="7" r="4" />
            </Icon>
        );
        const MessageSquare = (props) => (
            <Icon {...props}>
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
            </Icon>
        );
        const Download = (props) => (
            <Icon {...props}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                <polyline points="7 10 12 15 17 10" />
                <line x1="12" y1="15" x2="12" y2="3" />
            </Icon>
        );
        const Upload = (props) => (
            <Icon {...props}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0  0 1-2-2v-4" />
                <polyline points="17 8 12 3 7 8" />
                <line x1="12" y1="3" x2="12" y2="15" />
            </Icon>
        );
        const RotateCcw = (props) => (
            <Icon {...props}>
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
                <path d="M21 3v5h-5" />
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
                <path d="M3 21v-5h5" />
            </Icon>
        );
        const Save = (props) => (
            <Icon {...props}>
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
                <polyline points="17 21 17 13 7 13 7 21" />
                <polyline points="7 3 7 8 15 8" />
            </Icon>
        );


        const App = () => {
          // React Hooks are now accessed via React. prefix
          const useState = React.useState;
          const useEffect = React.useEffect;
          const useCallback = React.useCallback;

          // 選手候補のリスト
          const playerCandidates = [
            '選択してください', // Default option
            'しょうちゃん', 'トモ', 'キタ', 'ノム', 'ムラヤマ', 'サワ', 'ヒロキ',
            'タカヒト', 'ケイジ', 'ヒビキ', 'カツキ', 'イトウ', 'ケイヤ', 'トシキ',
            'トモミ', 'ショウタ', 'ヤマグチ', 'ソラ', 'エンマ'
          ];

          // Formation definitions with positions and coordinates
          const formations = {
            '4-4-2': {
              name: '4-4-2',
              positions: [
                { id: 'gk', label: 'GK', count: 1, type: 'goalkeeper', abbr: 'GK' },
                { id: 'lb', label: 'LSB', count: 1, type: 'defender', abbr: 'LSB' },
                { id: 'cb1', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'cb2', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'rb', label: 'RSB', count: 1, type: 'defender', abbr: 'RSB' },
                { id: 'lm', label: 'LM', count: 1, type: 'midfielder', abbr: 'LM' },
                { id: 'cm1', label: 'MF', count: 1, type: 'midfielder', abbr: 'MF' }, // Changed label and abbr
                { id: 'cm2', label: 'MF', count: 1, type: 'midfielder', abbr: 'MF' }, // Changed label and abbr
                { id: 'rm', label: 'RM', count: 1, type: 'midfielder', abbr: 'RM' },
                { id: 'st1', label: 'FW', count: 1, type: 'forward', abbr: 'FW' },
                { id: 'st2', label: 'FW', count: 1, type: 'forward', abbr: 'FW' },
              ],
              coords: {
                gk: { x: 50, y: 92 },
                lb: { x: 15, y: 65 },
                cb1: { x: 40, y: 70 }, // Adjusted CB position
                cb2: { x: 60, y: 70 }, // Adjusted CB position
                rb: { x: 85, y: 65 },
                lm: { x: 18, y: 35 },
                cm1: { x: 40, y: 40 },
                cm2: { x: 60, y: 40 },
                rm: { x: 82, y: 35 },
                st1: { x: 40, y: 15 },
                st2: { x: 60, y: 15 },
              },
            },
            '4-3-3': {
              name: '4-3-3',
              positions: [
                { id: 'gk', label: 'GK', count: 1, type: 'goalkeeper', abbr: 'GK' },
                { id: 'lb', label: 'LSB', count: 1, type: 'defender', abbr: 'LSB' },
                { id: 'cb1', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'cb2', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'rb', label: 'RSB', count: 1, type: 'defender', abbr: 'RSB' },
                { id: 'cm1', label: 'MF', count: 1, type: 'midfielder', abbr: 'MF' }, // Changed label and abbr
                { id: 'cdm', label: 'DMF', count: 1, type: 'midfielder', abbr: 'DMF' },
                { id: 'cm2', label: 'MF', count: 1, type: 'midfielder', abbr: 'MF' }, // Changed label and abbr
                { id: 'lw', label: 'LWG', count: 1, type: 'forward', abbr: 'LWG' },
                { id: 'st', label: 'FW', count: 1, type: 'forward', abbr: 'FW' },
                { id: 'rw', label: 'RWG', count: 1, type: 'forward', abbr: 'RWG' },
              ],
              coords: {
                gk: { x: 50, y: 92 },
                lb: { x: 15, y: 65 },
                cb1: { x: 40, y: 70 }, // Adjusted CB position
                cb2: { x: 60, y: 70 }, // Adjusted CB position
                rb: { x: 85, y: 65 },
                cm1: { x: 30, y: 45 },
                cdm: { x: 50, y: 55 },
                cm2: { x: 70, y: 45 },
                lw: { x: 25, y: 15 },
                st: { x: 50, y: 10 },
                rw: { x: 75, y: 15 },
              },
            },
            '3-5-2': {
              name: '3-5-2',
              positions: [
                { id: 'gk', label: 'GK', count: 1, type: 'goalkeeper', abbr: 'GK' },
                { id: 'cb1', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'cb2', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'cb3', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'lwb', label: 'LWB', count: 1, type: 'midfielder', abbr: 'LWB' },
                { id: 'lm', label: 'LM', count: 1, type: 'midfielder', abbr: 'LM' },
                { id: 'cdm', label: 'DMF', count: 1, type: 'midfielder', abbr: 'DMF' },
                { id: 'rm', label: 'RM', count: 1, type: 'midfielder', abbr: 'RM' },
                { id: 'rwb', label: 'RWB', count: 1, type: 'midfielder', abbr: 'RWB' },
                { id: 'st1', label: 'FW', count: 1, type: 'forward', abbr: 'FW' },
                { id: 'st2', label: 'FW', count: 1, type: 'forward', abbr: 'FW' },
              ],
              coords: {
                gk: { x: 50, y: 92 },
                cb1: { x: 30, y: 70 }, // Adjusted CB position
                cb2: { x: 50, y: 75 },
                cb3: { x: 70, y: 70 }, // Adjusted CB position
                lwb: { x: 10, y: 50 },
                lm: { x: 30, y: 35 },
                cdm: { x: 50, y: 50 },
                rm: { x: 70, y: 35 },
                rwb: { x: 90, y: 50 },
                st1: { x: 40, y: 15 },
                st2: { x: 60, y: 15 },
              },
            },
            '4-2-3-1': {
              name: '4-2-3-1',
              positions: [
                { id: 'gk', label: 'GK', count: 1, type: 'goalkeeper', abbr: 'GK' },
                { id: 'lb', label: 'LSB', count: 1, type: 'defender', abbr: 'LSB' },
                { id: 'cb1', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'cb2', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'rb', label: 'RSB', count: 1, type: 'defender', abbr: 'RSB' },
                { id: 'dmf1', label: 'DMF', count: 1, type: 'midfielder', abbr: 'DMF' },
                { id: 'dmf2', label: 'DMF', count: 1, type: 'midfielder', abbr: 'DMF' },
                { id: 'lam', label: 'LWG', count: 1, type: 'midfielder', abbr: 'LWG' },
                { id: 'cam', label: 'OMF', count: 1, type: 'midfielder', abbr: 'OMF' },
                { id: 'ram', label: 'RWG', count: 1, type: 'midfielder', abbr: 'RWG' },
                { id: 'st', label: 'FW', count: 1, type: 'forward', abbr: 'FW' },
              ],
              coords: {
                gk: { x: 50, y: 92 },
                lb: { x: 15, y: 65 },
                cb1: { x: 40, y: 70 }, // Adjusted CB position
                cb2: { x: 60, y: 70 }, // Adjusted CB position
                rb: { x: 85, y: 65 },
                dmf1: { x: 40, y: 48 }, // Moved DMF1 higher (from 50)
                dmf2: { x: 60, y: 48 }, // Moved DMF2 higher (from 50)
                lam: { x: 25, y: 25 },
                cam: { x: 50, y: 30 },
                ram: { x: 75, y: 25 },
                st: { x: 50, y: 10 },
              },
            },
            '5-3-2': {
              name: '5-3-2',
              positions: [
                { id: 'gk', label: 'GK', count: 1, type: 'goalkeeper', abbr: 'GK' },
                { id: 'lwb', label: 'LWB', count: 1, type: 'defender', abbr: 'LWB' },
                { id: 'cb1', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'cb2', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'cb3', label: 'CB', count: 1, type: 'defender', abbr: 'CB' },
                { id: 'rwb', label: 'RWB', count: 1, type: 'defender', abbr: 'RWB' },
                { id: 'cm1', label: 'MF', count: 1, type: 'midfielder', abbr: 'MF' }, // Changed label and abbr
                { id: 'cdm', label: 'DMF', count: 1, type: 'midfielder', abbr: 'DMF' },
                { id: 'cm2', label: 'MF', count: 1, type: 'midfielder', abbr: 'MF' }, // Changed label and abbr
                { id: 'st1', label: 'FW', count: 1, type: 'forward', abbr: 'FW' },
                { id: 'st2', label: 1, type: 'forward', abbr: 'FW' }, // Corrected count to 1
              ],
              coords: {
                gk: { x: 50, y: 92 },
                lwb: { x: 10, y: 65 },
                cb1: { x: 30, y: 75 }, // Adjusted CB position
                cb2: { x: 50, y: 78 },
                cb3: { x: 70, y: 75 }, // Adjusted CB position
                rwb: { x: 90, y: 65 },
                cm1: { x: 30, y: 40 },
                cdm: { x: 50, y: 50 },
                cm2: { x: 70, y: 40 },
                st1: { x: 40, y: 15 },
                st2: { x: 60, y: 15 },
              },
            },
          };

          const [selectedFormation, setSelectedFormation] = useState('4-4-2');
          const [playerNames, setPlayerNames] = useState({});
          const [dropdownOpen, setDropdownOpen] = useState(false);
          const [comments, setComments] = useState('');
          const [teamName, setTeamName] = useState('');
          const [savedFormations, setSavedFormations] = useState([]);

          // Initialize player names when formation changes
          useEffect(() => {
            const initialNames = {};
            const currentFormationPositions = formations[selectedFormation].positions;
            currentFormationPositions.forEach(pos => {
              // Retain existing player name if the position ID remains the same, otherwise set to empty string.
              initialNames[pos.id] = playerNames[pos.id] || '';
            });
            setPlayerNames(initialNames);
          }, [selectedFormation, formations]); // Removed playerNames from dependency array to prevent infinite loop

          const handlePlayerNameChange = useCallback((positionId, name) => {
            setPlayerNames(prevNames => ({
              ...prevNames,
              [positionId]: name,
            }));
          }, []);

          const handleFormationChange = useCallback((formationName) => {
            setSelectedFormation(formationName);
            setDropdownOpen(false);
          }, []);

          const toggleDropdown = useCallback(() => {
            setDropdownOpen(prev => !prev);
          }, []);

          const handleCommentsChange = useCallback((e) => {
            setComments(e.target.value);
          }, []);

          const handleTeamNameChange = useCallback((e) => {
            setTeamName(e.target.value);
          }, []);

          // Save current formation
          const saveFormation = useCallback(() => {
            const formationData = {
              id: Date.now(),
              name: teamName || `${formations[selectedFormation].name} - ${new Date().toLocaleDateString()}`,
              formation: selectedFormation,
              players: { ...playerNames },
              comments,
              createdAt: new Date().toISOString(),
            };
            setSavedFormations(prev => [...prev, formationData]);
            // Replace alert with a custom modal or message box
            // alert('フォーメーションが保存されました！');
            // For now, a simple console log as a placeholder for UI feedback
            console.log('フォーメーションが保存されました！');
          }, [selectedFormation, playerNames, comments, teamName, formations]);

          // Load saved formation
          const loadFormation = useCallback((savedFormation) => {
            setSelectedFormation(savedFormation.formation);
            setPlayerNames(savedFormation.players);
            setComments(savedFormation.comments);
            setTeamName(savedFormation.name);
          }, []);

          // Clear all data
          const clearAll = useCallback(() => {
            setPlayerNames({}); // Reset player names to empty (or '選択してください')
            setComments('');
            setTeamName('');
          }, []);

          // Export formation as image
          const exportFormation = useCallback(() => {
            const exportElement = document.getElementById('formation-export-area');
            if (!exportElement) return;

            // Create a canvas element
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            const scale = 2; // Higher scale for better quality
            canvas.width = 800 * scale;
            canvas.height = 1200 * scale; 
            ctx.scale(scale, scale);
            
            // Fill background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 800, 1200);
            
            // Draw team name
            if (teamName) {
              ctx.fillStyle = '#1f2937';
              ctx.font = 'bold 24px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText(teamName, 400, 40);
            }
            
            // Draw formation name
            ctx.fillStyle = '#1f2937';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(formations[selectedFormation].name, 400, teamName ? 70 : 40);
            
            // Draw soccer field
            const fieldY = teamName ? 70 : 50;
            const fieldWidth = 350;
            const fieldHeight = 580; 
            const fieldX = (800 - fieldWidth) / 2;
            
            // Field background
            ctx.fillStyle = '#16a34a';
            ctx.fillRect(fieldX, fieldY, fieldWidth, fieldHeight);
            
            // Field border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(fieldX, fieldY, fieldWidth, fieldHeight);
            
            // Center line
            ctx.beginPath();
            ctx.moveTo(fieldX, fieldY + fieldHeight / 2);
            ctx.lineTo(fieldX + fieldWidth, fieldY + fieldHeight / 2);
            ctx.stroke();
            
            // Center circle
            ctx.beginPath();
            ctx.arc(fieldX + fieldWidth / 2, fieldY + fieldHeight / 2, 40, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Goal areas
            const goalWidth = 80;
            const goalHeight = 30;
            // Top goal area
            ctx.strokeRect(fieldX + (fieldWidth - goalWidth) / 2, fieldY, goalWidth, goalHeight);
            // Bottom goal area
            ctx.strokeRect(fieldX + (fieldWidth - goalWidth) / 2, fieldY + fieldHeight - goalHeight, goalWidth, goalHeight);
            
            // Draw players
            Object.keys(formations[selectedFormation].coords).forEach(positionId => {
              const player = playerNames[positionId];
              const coord = formations[selectedFormation].coords[positionId];
              const position = formations[selectedFormation].positions.find(p => p.id === positionId);
              
              const x = fieldX + (coord.x / 100) * fieldWidth;
              let y = fieldY + (coord.y / 100) * fieldHeight; 

              if (positionId === 'gk') {
                y = fieldY + (95 / 100) * fieldHeight;
              }
              
              // Set text color based on position type (for canvas export)
              let textColor = '#ffffff';
              switch (position.type) {
                case 'goalkeeper': textColor = '#fbbf24'; break;
                case 'defender': textColor = '#ef4444'; break;
                case 'midfielder': textColor = '#3b82f6'; break;
                case 'forward': textColor = '#a855f7'; break;
                default: textColor = '#6b7280'; break;
              }
              
              // Conditional rendering: if player name exists, show player name; otherwise, show position abbr
              if (player && player !== '' && player !== '選択してください') {
                ctx.fillStyle = '#ffffff'; // White text for player name
                ctx.font = '16px sans-serif'; 
                ctx.textAlign = 'center';
                ctx.fillText(player, x, y - 4); // Adjusted Y for better centering with player name only
              } else {
                ctx.fillStyle = textColor; 
                ctx.font = '18px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(position.abbr, x, y - 4); // Adjusted Y to move up
              }
            });
            
            // Draw comments section
            if (comments.trim()) {
              const commentsY = fieldY + fieldHeight + 60;
              
              // Comments title
              ctx.fillStyle = '#7c3aed';
              ctx.font = 'bold 16px sans-serif';
              ctx.textAlign = 'left';
              ctx.fillText('コメント・戦術', 50, commentsY);
              
              // Comments background
              ctx.fillStyle = '#f3f4f6';
              ctx.fillRect(50, commentsY + 10, 700, 120);
              ctx.strokeStyle = '#d1d5db';
              ctx.lineWidth = 1;
              ctx.strokeRect(50, commentsY + 10, 700, 120);
              
              // Comments text
              ctx.fillStyle = '#374151';
              ctx.font = '12px sans-serif';
              
              // Wrap text
              const lines = [];
              let currentLine = '';
              const words = comments.split(' ');
              const maxWidth = 680;

              for (let i = 0; i < words.length; i++) {
                const word = words[i];
                let testLine = currentLine ? currentLine + ' ' + word : word;
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;

                if (testWidth > maxWidth && currentLine !== '') {
                  lines.push(currentLine);
                  currentLine = word;
                } else {
                  currentLine = testLine;
                }
              }
              lines.push(currentLine);

              let lineY = commentsY + 30;
              const lineHeight = 16;
              for (let i = 0; i < lines.length; i++) {
                if (lineY + lineHeight > commentsY + 110) break;
                ctx.fillText(lines[i], 60, lineY);
                lineY += lineHeight;
              }
            }
            
            // Convert canvas to blob and download
            canvas.toBlob((blob) => {
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `formation-${teamName || selectedFormation}-${Date.now()}.png`;
              a.click();
              URL.revokeObjectURL(url);
            }, 'image/png');
          }, [selectedFormation, teamName, playerNames, comments, formations]);

          // Position color mapping (for UI display)
          const getPositionColor = (type) => {
            switch (type) {
              case 'goalkeeper': return 'text-yellow-500';
              case 'defender': return 'text-red-500';
              case 'midfielder': return 'text-blue-500';
              case 'forward': return 'text-purple-500';
              default: return 'text-gray-500';
            }
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex flex-col items-center justify-center p-4 font-inter">
              {/* Header */}
              <div className="text-center mb-8">
                <h1 className="text-4xl sm:text-5xl font-bold text-gray-800 mb-4 tracking-tight">
                  Partage Formation <span className="text-green-600">⚽</span>
                </h1>
                <p className="text-base sm:text-lg text-gray-600">Create and share your soccer team formations</p>
              </div>

              <div className="bg-white rounded-3xl shadow-2xl p-6 w-full max-w-7xl">
                {/* Team Name Input */}
                <div className="mb-6 text-center">
                  <input
                    type="text"
                    placeholder="チーム名を入力してください..."
                    value={teamName}
                    onChange={handleTeamNameChange}
                    className="text-xl sm:text-2xl font-bold text-center border-b-2 border-gray-300 focus:border-blue-500 bg-transparent outline-none px-4 py-2 w-full max-w-md rounded-md"
                  />
                </div>

                {/* Action Buttons */}
                <div className="flex flex-wrap justify-center gap-3 mb-6">
                  <button
                    onClick={saveFormation}
                    className="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition duration-200 shadow-md hover:shadow-lg"
                  >
                    <Save size={16} /> 保存
                  </button>
                  <button
                    onClick={exportFormation}
                    className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition duration-200 shadow-md hover:shadow-lg"
                  >
                    <Download size={16} /> 画像エクスポート
                  </button>
                  <button
                    onClick={clearAll}
                    className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 transition duration-200 shadow-md hover:shadow-lg"
                  >
                    <RotateCcw size={16} /> クリア
                  </button>
                </div>

                <div className="flex flex-col lg:flex-row gap-6">
                  {/* Left: Formation Selection */}
                  <div className="w-full lg:w-1/4 p-4 bg-gradient-to-br from-blue-50 to-blue-100 rounded-2xl shadow-inner">
                    <h2 className="text-xl sm:text-2xl font-semibold text-blue-800 mb-6 flex items-center">
                      <Users className="mr-2 text-blue-600" /> フォーメーション
                    </h2>
                    <div className="relative w-full">
                      <button
                        onClick={toggleDropdown}
                        className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-xl shadow-lg flex items-center justify-between transition duration-300 ease-in-out transform hover:scale-105"
                      >
                        <span>{formations[selectedFormation].name}</span>
                        <ChevronDown className={`ml-2 transition-transform duration-300 ${dropdownOpen ? 'rotate-180' : 'rotate-0'}`} />
                      </button>
                      {dropdownOpen && (
                        <div className="absolute z-20 w-full mt-2 bg-white rounded-xl shadow-xl overflow-hidden border border-blue-200">
                          {Object.keys(formations).map((key) => (
                            <button
                              key={key}
                              onClick={() => handleFormationChange(key)}
                              className={`block w-full text-left px-4 py-3 text-gray-800 hover:bg-blue-100 transition duration-200 ${
                                selectedFormation === key ? 'bg-blue-50 font-semibold text-blue-700' : ''
                              }`}
                            >
                              {formations[key].name}
                            </button>
                          ))}
                        </div>
                      )}
                    </div>

                    {/* Saved Formations */}
                    {savedFormations.length > 0 && (
                      <div className="mt-6">
                        <h3 className="text-lg font-semibold text-blue-800 mb-3">保存済み</h3>
                        <div className="space-y-2 max-h-40 overflow-y-auto">
                          {savedFormations.map((saved) => (
                            <button
                              key={saved.id}
                              onClick={() => loadFormation(saved)}
                              className="w-full text-left p-2 bg-white rounded-lg hover:bg-blue-50 transition duration-200 text-sm border border-blue-200"
                            >
                              <div className="font-medium truncate">{saved.name}</div>
                              <div className="text-gray-500 text-xs">{saved.formation}</div>
                            </button>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>

                  {/* Center: Player Input (Input with Datalist) */}
                  <div className="w-full lg:w-1/3 p-4 bg-gradient-to-br from-green-50 to-green-100 rounded-2xl shadow-inner overflow-y-auto max-h-[70vh]">
                    <h2 className="text-xl sm:text-2xl font-semibold text-green-800 mb-6 flex items-center">
                      <User className="mr-2 text-green-600" /> 選手名入力
                    </h2>
                    <div className="grid grid-cols-1 gap-4">
                      {formations[selectedFormation].positions.map(pos => (
                        <div key={pos.id} className="flex flex-col">
                          <label htmlFor={pos.id} className="text-sm font-medium text-gray-700 mb-1 flex items-center">
                            {pos.type === 'goalkeeper' && <Goal className="w-4 h-4 mr-1 text-yellow-600" />}
                            {pos.type === 'defender' && <Shield className="w-4 h-4 mr-1 text-red-600" />}
                            {pos.type === 'midfielder' && <Users className="w-4 h-4 mr-1 text-blue-600" />}
                            {pos.type === 'forward' && <Swords className="w-4 h-4 mr-1 text-purple-600" />}
                            <span className="font-bold">{pos.abbr}</span>
                          </label>
                          <input
                            type="text"
                            id={pos.id}
                            list={`player-candidates-${pos.id}`}
                            value={playerNames[pos.id] || ''}
                            onChange={(e) => handlePlayerNameChange(pos.id, e.target.value)}
                            placeholder={`${pos.label} の選手名`}
                            className="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-400 focus:border-transparent transition duration-200 shadow-sm"
                          />
                          <datalist id={`player-candidates-${pos.id}`}>
                            {playerCandidates.filter(name => name !== '選択してください').map(playerName => (
                              <option key={playerName} value={playerName} />
                            ))}
                          </datalist>
                        </div>
                      ))}
                    </div>
                  </div>

                  {/* Right: Formation Display and Comments */}
                  <div className="w-full lg:w-2/5 flex flex-col items-center" id="formation-export-area">
                    {/* Formation Display */}
                    <div className="w-full mb-6">
                      <h2 className="text-xl sm:text-3xl font-bold text-gray-800 mb-4 text-center">
                        {teamName && <div className="text-base sm:text-lg text-gray-600 mb-2">{teamName}</div>}
                        {formations[selectedFormation].name}
                      </h2>
                      
                      {/* Soccer Field */}
                      <div className="relative bg-green-600 rounded-2xl shadow-2xl overflow-hidden w-full mx-auto border-4 border-white"
                           style={{ aspectRatio: '4/3', maxWidth: '400px' }}>
                        {/* Field markings */}
                        <div className="absolute inset-0">
                          {/* Center line (changed from vertical to horizontal) */}
                          <div className="absolute top-1/2 left-0 w-full h-0.5 bg-white opacity-70 transform -translate-y-0.5"></div>
                          {/* Center circle */}
                          <div className="absolute top-1/2 left-1/2 w-20 h-20 border-2 border-white opacity-70 rounded-full transform -translate-x-1/2 -translate-y-1/2"></div>
                          {/* Goal areas */}
                          <div className="absolute bottom-0 left-1/2 w-16 h-8 border-2 border-white border-b-0 opacity-70 transform -translate-x-1/2"></div>
                          <div className="absolute top-0 left-1/2 w-16 h-8 border-2 border-white border-t-0 opacity-70 transform -translate-x-1/2"></div>
                        </div>

                        {/* Player positions */}
                        {Object.keys(formations[selectedFormation].coords).map(positionId => {
                          const player = playerNames[positionId];
                          const coord = formations[selectedFormation].coords[positionId];
                          const position = formations[selectedFormation].positions.find(p => p.id === positionId);

                          return (
                            <div
                              key={positionId}
                              className="absolute flex flex-col items-center justify-center text-center w-fit h-fit"
                              style={{
                                left: `${coord.x}%`,
                                top: `${coord.y}%`,
                                transform: 'translate(-50%, -50%)',
                                textShadow: '2px 2px 4px rgba(0,0,0,0.8)',
                                lineHeight: '1.4',
                              }}
                            >
                              {/* Player Name or Position Abbreviation */}
                              {/* If player name exists, show player name; otherwise, show position abbr */}
                              {player && player !== '' && player !== '選択してください' ? (
                                <div className="text-lg font-medium max-w-20 truncate text-white">
                                  {player}
                                </div>
                              ) : (
                                <div className={`text-lg ${getPositionColor(position.type)}`}>
                                  {position.abbr}
                                </div>
                              )}
                            </div>
                          );
                        })}
                      </div>
                    </div>

                    {/* Comments Section */}
                    <div className="w-full p-4 bg-gradient-to-br from-purple-50 to-purple-100 rounded-2xl shadow-inner">
                      <h2 className="text-xl sm:text-2xl font-semibold text-purple-800 mb-4 flex items-center">
                        <MessageSquare className="mr-2 text-purple-600" /> コメント・戦術
                      </h2>
                      <textarea
                        className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-400 focus:border-transparent transition duration-200 shadow-sm resize-none"
                        rows="4"
                        placeholder="戦術やコメントを入力してください..."
                        value={comments}
                        onChange={handleCommentsChange}
                      ></textarea>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        // Render the React component into the root div
        const domNode = document.getElementById('root');
        const root = ReactDOM.createRoot(domNode);
        root.render(<App />);
    </script>
</body>
</html>
